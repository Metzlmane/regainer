#!/usr/bin/env python3

import subprocess
import argparse
import asyncio
import multiprocessing
import re
from collections import deque
import mutagen
from math import log10

class AlbumAction(argparse.Action):
    def __init__(self, option_strings, dest, **kwargs):
        super(AlbumAction, self).__init__(option_strings, dest, **kwargs)
    def __call__(self, parser, namespace, values, option_string=None):
        if namespace.album is None:
            namespace.album = deque()
        if option_string == '--album':
            namespace.album.append({'track': deque(values), 'exclude': deque()})
        if option_string == '--exclude':
            if len(namespace.album) == 0:
                if namespace.exclude is None:
                    namespace.exclude = values
                else:
                    namespace.exclude.extend(values)
            else:
                namespace.album[-1]['exclude'].extend(values)

class TrackAction(argparse.Action):
    def __init__(self, option_strings, dest, **kwargs):
        super(TrackAction, self).__init__(option_strings, dest, **kwargs)
    def __call__(self, parser, namespace, values, option_string=None):
        if namespace.track is None:
            namespace.track = deque(values)
        else:
            namespace.track.extend(values)

parser = argparse.ArgumentParser(
        description='''
        Add ReplayGain tags to files using the EBU R128 algorithm.
        ''',
        epilog='''
        If neither --track or --album are specified, the mode used depends on
        the number of files given as arguments. If a single file is given, it
        will be processed in track mode. If multiple files are given, they
        will be processed in album mode as a single album.
        ''')
parser.add_argument('-j', '--jobs', type=int, default=multiprocessing.cpu_count(),
        help='''
        The number of operations to run in parallel. The default is
        auto-detected, currently %(default)s.
        ''')
parser.add_argument('-t', '--track', nargs='+', default=deque(),
        metavar='FILE', action=TrackAction,
        help='''
        Treat the following audio files as individual tracks.
        ''')
parser.add_argument('-a', '--album', nargs='+', default=deque(),
        metavar='FILE', action=AlbumAction,
        help='''
        Treat the following audio files as part of the same album.
        Each time the --album option is specified, it starts a new album.
        ''')
parser.add_argument('-e', '--exclude', nargs='+', default=deque(),
        metavar='FILE', action=AlbumAction,
        help='''
        Tag the following files as part of the current album, but do not
        use their audio when calculating the value for the album ReplayGain
        tag.
        ''')
parser.add_argument('FILE', nargs='*', default=[], help=argparse.SUPPRESS)
args = parser.parse_args()

# Handle the "loose" arguments, by turning them into tracks or albums
if len(args.FILE) + len(args.exclude) > 1 or len(args.exclude) > 0:
    # Treat the initial arguments as an album
    args.album.appendleft(
            {'track': deque(args.FILE), 'exclude': deque(args.exclude)})
    args.FILE = None
    args.exclude = None
elif len(args.FILE) > 0:
    args.track.extend(args.FILE)
    args.FILE = None

print(vars(args))

class GainInfo:
    def __init__(self, loudness=None, album_loudness=None,
            peak=None, album_peak=None):
        self.loudness = loudness
        self.album_loudness = album_loudness
        self.peak = peak
        self.album_peak = album_peak

    def __str__(self):
        str = ''
        str += 'Track: '
        if self.loudness:
            str += 'I: {:.2f} LUFS'.format(self.loudness)
        else:
            str += 'I: None'
        str += ', '
        if self.peak:
            str += 'Peak: {:.2f} dBFS'.format(self.peak)
        else:
            str += 'Peak: None'
        str += '; Album: '
        if self.album_loudness:
            str += 'I: {:.2f} LUFS'.format(self.album_loudness)
        else:
            str += 'I: None'
        str += ', '
        if self.album_peak:
            str += 'Peak: {:.2f} dBFS'.format(self.album_peak)
        else:
            str += 'Peak: None'
        return str

class Tagger:
    REPLAYGAIN_REF = -18.0 # LUFS
    BS1770_REF = -23.0 # LUFS
    def __init__(self, filename):
        self.filename = filename
        self.tags = GainInfo()

    rg_gain_re = re.compile(r"^\s*([+-]?\d+(?:\.\d+)?)")
    def parse_rg_gain(self, value):
        m = self.rg_gain_re.match(value)
        if m:
            return self.REPLAYGAIN_REF - float(m.group(1))
        return None

    rg_peak_re = re.compile(r"^\s*([+-]?\d+(?:\.\d+)?)")
    def parse_rg_peak(self, value):
        m = self.rg_peak_re.match(value)
        if m:
            return 20.0 * log10(float(m.group(1)))
        return None
        

    def read_gain_id3(self):
        # Read from the current preferred tags first
        rg_tg = self.audio.get('TXXX:REPLAYGAIN_TRACK_GAIN')
        if rg_tg:
            self.tags.loudness = self.parse_rg_gain(rg_tg.text[0])
        rg_tp = self.audio.get('TXXX:REPLAYGAIN_TRACK_PEAK')
        if rg_tp:
            self.tags.peak = self.parse_rg_peak(rg_tp.text[0])
        rg_ag = self.audio.get('TXXX:REPLAYGAIN_ALBUM_GAIN')
        if rg_ag:
            self.tags.album_loudness = self.parse_rg_gain(rg_ag.text[0])
        rg_ap = self.audio.get('TXXX:REPLAYGAIN_ALBUM_PEAK')
        if rg_ap:
            self.tags.album_peak = self.parse_rg_peak(rg_ap.text[0])

        # Try loading the legacy RVA2 tags if information is missing
        if not self.tags.loudness:
            rva2_t = self.audio.get('RVA2:track')
            if rva2_t and rva2_t.channel == 1:
                self.tags.loudness = self.REPLAYGAIN_REF - rva2_t.gain
                self.tags.peak = 20.0 * log10(rva2_t.peak)
        if not self.tags.album_loudness:
            rva2_a = self.audio.get('RVA2:album')
            if rva2_a and rva2_a.channel == 1:
                self.tags.album_loudness = self.REPLAYGAIN_REF - rva2_a.gain
                self.tags.album_peak = 20.0 * log10(rva2_a.peak)

        
        return self.tags

    def read_gain(self):
        self.audio = mutagen.File(self.filename)
        if isinstance(self.audio, mutagen.id3.ID3FileType):
            return self.read_gain_id3()
        if isinstance(self.audio, mutagen.oggopus.OggOpus):
            return self.read_gain_ogg_opus()
        if isinstance(self.audio, mutagen.mp4.MP4):
            return self.read_gain_mp4()
        return self.read_gain_generic()

class GainScanner:
    i_re = re.compile(r"^\s+I:\s+(-?\d+\.\d+) LUFS$", re.M)
    peak_re = re.compile(r"^\s+Peak:\s+(-?\d+\.\d+) dBFS$", re.M)

    def __init__(self, job_sem):
        self.job_sem = job_sem

    @asyncio.coroutine
    def ffmpeg_parse_ebur128(self, *ff_opts):
        with (yield from job_sem):
            ff_args = ['ffmpeg', '-nostats', '-nostdin', '-hide_banner',
                    '-loglevel', 'info'] + list(ff_opts) + ['-f', 'null', '-']
            ffmpeg = yield from asyncio.create_subprocess_exec(*ff_args,
                    stdin=subprocess.DEVNULL, stdout=subprocess.DEVNULL,
                    stderr=subprocess.PIPE)
            (_, stderr_data) = yield from ffmpeg.communicate()
            stderr_str = stderr_data.decode()

            result = GainInfo()
            m = self.i_re.search(stderr_str)
            if m:
                result.loudness = float(m.group(1))
            m = self.peak_re.search(stderr_str)
            if m:
                result.peak = float(m.group(1))

            return result

    @asyncio.coroutine
    def scan_track(self, filename):
        result = yield from self.ffmpeg_parse_ebur128('-i', filename,
                '-filter_complex', 'ebur128=framelog=verbose:peak=true')
        return result

    @asyncio.coroutine
    def scan_album(self, filenames):
        if len(filenames) == 0:
            raise ValueError("filenames is empty")
        ff_args = []
        for filename in filenames:
            ff_args += ['-i', filename]
        ff_args += ['-filter_complex',
                'concat=n={}:v=0:a=1,ebur128=framelog=verbose'.format(len(filenames))]
        print(ff_args)
        result = yield from self.ffmpeg_parse_ebur128(*ff_args)
        return GainInfo(album_loudness=result.loudness, album_peak=result.peak)

class TrackGainScanner:
    def __init__(self, job_sem):
        self.gain_scanner = GainScanner(job_sem)

    @asyncio.coroutine
    def scan_track(self, track):
        result = yield from self.gain_scanner.scan_track(track)
        tagger = Tagger(track)
        tags = tagger.read_gain()
        print(track)
        print(tags)
        print(result)

    def scan(self, tracks):
        track_tasks = [self.scan_track(track) for track in tracks]
        return asyncio.gather(*track_tasks)

class AlbumGainScanner:
    def __init__(self, job_sem):
        self.gain_scanner = GainScanner(job_sem)

    @asyncio.coroutine
    def scan_album(self, album):
        result = yield from self.gain_scanner.scan_album(album['track'])
        print("Album:")
        print(result)

    @asyncio.coroutine
    def scan_track(self, track):
        result = yield from self.gain_scanner.scan_track(track)
        tagger = Tagger(track)
        tags = tagger.read_gain()
        print(track)
        print(tags)
        print(result)

    def scan(self, album):
        album_task = self.scan_album(album)
        track_tasks = [self.scan_track(track) for track in album['track']]
        track_tasks += [self.scan_track(track) for track in album['exclude']]
        return asyncio.gather(album_task, *track_tasks)

loop = asyncio.get_event_loop()

job_sem = asyncio.BoundedSemaphore(args.jobs)

track_scanner = TrackGainScanner(job_sem)
album_scanner = AlbumGainScanner(job_sem)

track_task = track_scanner.scan(args.track)
album_tasks = [album_scanner.scan(album) for album in args.album]

future = asyncio.async(asyncio.gather(track_task, *album_tasks))

loop.run_until_complete(future)

future.result()

loop.close()
