#!/usr/bin/env python3

import subprocess
import argparse
import asyncio
import multiprocessing
import re
from collections import deque
import mutagen
from math import log10

class AlbumAction(argparse.Action):
    def __init__(self, option_strings, dest, **kwargs):
        super(AlbumAction, self).__init__(option_strings, dest, **kwargs)
    def __call__(self, parser, namespace, values, option_string=None):
        if namespace.album is None:
            namespace.album = deque()
        if option_string == '--album':
            namespace.album.append({'track': deque(values), 'exclude': deque()})
        if option_string == '--exclude':
            if len(namespace.album) == 0:
                if namespace.exclude is None:
                    namespace.exclude = values
                else:
                    namespace.exclude.extend(values)
            else:
                namespace.album[-1]['exclude'].extend(values)

class TrackAction(argparse.Action):
    def __init__(self, option_strings, dest, **kwargs):
        super(TrackAction, self).__init__(option_strings, dest, **kwargs)
    def __call__(self, parser, namespace, values, option_string=None):
        if namespace.track is None:
            namespace.track = deque(values)
        else:
            namespace.track.extend(values)

parser = argparse.ArgumentParser(
        description='''
        Add ReplayGain tags to files using the EBU R128 algorithm.
        ''',
        epilog='''
        If neither --track or --album are specified, the mode used depends on
        the number of files given as arguments. If a single file is given, it
        will be processed in track mode. If multiple files are given, they
        will be processed in album mode as a single album.
        ''')
parser.add_argument('-f', '--force', default=False, action='store_true',
        help='''
        Recalculate the ReplayGain values even if valid tags are already
        present in the files.
        ''')
parser.add_argument('-j', '--jobs', type=int,
        default=multiprocessing.cpu_count(),
        help='''
        The number of operations to run in parallel. The default is
        auto-detected, currently %(default)s.
        ''')
parser.add_argument('-t', '--track', nargs='+', default=deque(),
        metavar='FILE', action=TrackAction,
        help='''
        Treat the following audio files as individual tracks.
        ''')
parser.add_argument('-a', '--album', nargs='+', default=deque(),
        metavar='FILE', action=AlbumAction,
        help='''
        Treat the following audio files as part of the same album.
        Each time the --album option is specified, it starts a new album.
        ''')
parser.add_argument('-e', '--exclude', nargs='+', default=deque(),
        metavar='FILE', action=AlbumAction,
        help='''
        Tag the following files as part of the current album, but do not
        use their audio when calculating the value for the album ReplayGain
        tag.
        ''')
parser.add_argument('FILE', nargs='*', default=[], help=argparse.SUPPRESS)
args = parser.parse_args()

# Handle the "loose" arguments, by turning them into tracks or albums
if len(args.FILE) + len(args.exclude) > 1 or len(args.exclude) > 0:
    # Treat the initial arguments as an album
    args.album.appendleft(
            {'track': deque(args.FILE), 'exclude': deque(args.exclude)})
    args.FILE = None
    args.exclude = None
elif len(args.FILE) > 0:
    args.track.extend(args.FILE)
    args.FILE = None

class GainInfo:
    def __init__(self, loudness=None, album_loudness=None,
            peak=None, album_peak=None):
        self.loudness = loudness
        self.album_loudness = album_loudness
        self.peak = peak
        self.album_peak = album_peak

    def __str__(self):
        str = ''
        str += 'Track: '
        if self.loudness is None:
            str += 'I: None'
        else:
            str += 'I: {:.2f} LUFS'.format(self.loudness)
        str += ', '
        if self.peak is None:
            str += 'Peak: None'
        else:
            str += 'Peak: {:.2f} dBFS'.format(self.peak)
        str += '; Album: '
        if self.album_loudness is None:
            str += 'I: None'
        else:
            str += 'I: {:.2f} LUFS'.format(self.album_loudness)
        str += ', '
        if self.album_peak is None:
            str += 'Peak: None'
        else:
            str += 'Peak: {:.2f} dBFS'.format(self.album_peak)
        return str

class Tagger:
    REPLAYGAIN_REF = -18.0 # LUFS
    BS1770_REF = -23.0 # LUFS
    def __init__(self, filename):
        self.filename = filename
        self.tags = GainInfo()

    rg_gain_re = re.compile(r"^\s*([+-]?\d+(?:\.\d+)?)")
    def parse_rg_gain(self, value):
        m = self.rg_gain_re.match(value)
        if m:
            return self.REPLAYGAIN_REF - float(m.group(1))
        return None

    rg_peak_re = re.compile(r"^\s*([+-]?\d+(?:\.\d+)?)")
    def parse_rg_peak(self, value):
        m = self.rg_peak_re.match(value)
        if m:
            return 20.0 * log10(float(m.group(1)))
        return None
        

    def read_gain_id3(self):
        # Read from the current preferred tags first
        rg_tg = self.audio.get('TXXX:REPLAYGAIN_TRACK_GAIN')
        if rg_tg:
            self.tags.loudness = self.parse_rg_gain(rg_tg.text[0])
        rg_tp = self.audio.get('TXXX:REPLAYGAIN_TRACK_PEAK')
        if rg_tp:
            self.tags.peak = self.parse_rg_peak(rg_tp.text[0])
        rg_ag = self.audio.get('TXXX:REPLAYGAIN_ALBUM_GAIN')
        if rg_ag:
            self.tags.album_loudness = self.parse_rg_gain(rg_ag.text[0])
        rg_ap = self.audio.get('TXXX:REPLAYGAIN_ALBUM_PEAK')
        if rg_ap:
            self.tags.album_peak = self.parse_rg_peak(rg_ap.text[0])

        # Try loading the legacy RVA2 tags if information is missing
        if not self.tags.loudness:
            rva2_t = self.audio.get('RVA2:track')
            if rva2_t and rva2_t.channel == 1:
                self.tags.loudness = self.REPLAYGAIN_REF - rva2_t.gain
                self.tags.peak = 20.0 * log10(rva2_t.peak)
        if not self.tags.album_loudness:
            rva2_a = self.audio.get('RVA2:album')
            if rva2_a and rva2_a.channel == 1:
                self.tags.album_loudness = self.REPLAYGAIN_REF - rva2_a.gain
                self.tags.album_peak = 20.0 * log10(rva2_a.peak)

        return self.tags

    def read_gain_generic(self):
        rg_tg = self.audio.get('REPLAYGAIN_TRACK_GAIN')
        if rg_tg is None:
            rg_tg = self.audio.get('replaygain_track_gain')
        if rg_tg:
            self.tags.loudness = self.parse_rg_gain(rg_tg[0])
        rg_tp = self.audio.get('REPLAYGAIN_TRACK_PEAK')
        if rg_tp is None:
            rg_tp = self.audio.get('replaygain_track_gain')
        if rg_tp:
            self.tags.peak = self.parse_rg_peak(rg_tp[0])
        rg_ag = self.audio.get('REPLAYGAIN_ALBUM_GAIN')
        if rg_ag is None:
            rg_ag = self.audio.get('replaygain_album_gain')
        if rg_ag:
            self.tags.album_loudness = self.parse_rg_gain(rg_ag[0])
        rg_ap = self.audio.get('REPLAYGAIN_ALBUM_PEAK')
        if rg_ap is None:
            rg_ap = self.audio.get('replaygain_album_peak')
        if rg_ap:
            self.tags.album_peak = self.parse_rg_peak(rg_ap[0])

        return self.tags

    def read_gain(self):
        self.audio = mutagen.File(self.filename)
        if isinstance(self.audio, mutagen.id3.ID3FileType):
            return self.read_gain_id3()
        if isinstance(self.audio, mutagen.oggopus.OggOpus):
            return self.read_gain_ogg_opus()
        if isinstance(self.audio, mutagen.mp4.MP4):
            return self.read_gain_mp4()
        return self.read_gain_generic()

    def format_rg_gain(self, loudness):
        return "{:.2f} dB".format(self.REPLAYGAIN_REF - loudness)

    def format_rg_peak(self, peak):
        return "{:.6f}".format(10.0 ** (peak / 20.0))

    def write_gain_generic(self):
        # Delete wrong-case and legacy tags
        if 'replaygain_track_gain' in self.audio:
            del self.audio['replaygain_track_gain']
        if 'replaygain_track_peak' in self.audio:
            del self.audio['replaygain_track_peak']
        if 'replaygain_album_gain' in self.audio:
            del self.audio['replaygain_album_gain']
        if 'replaygain_album_peak' in self.audio:
            del self.audio['replaygain_album_peak']
        if 'REPLAYGAIN_REFERENCE_LOUDNESS' in self.audio:
            del self.audio['REPLAYGAIN_REFERENCE_LOUDNESS']
        if 'replaygain_reference_loudness' in self.audio:
            del self.audio['replaygain_reference_loudness']

        self.audio['REPLAYGAIN_TRACK_GAIN'] = \
                [self.format_rg_gain(self.tags.loudness)]
        self.audio['REPLAYGAIN_TRACK_PEAK'] = \
                [self.format_rg_peak(self.tags.peak)]
        self.audio['REPLAYGAIN_ALBUM_GAIN'] = \
                [self.format_rg_gain(self.tags.album_loudness)]
        self.audio['REPLAYGAIN_ALBUM_PEAK'] = \
                [self.format_rg_peak(self.tags.album_peak)]

        self.audio.save()

    def write_gain(self, tags):
        self.tags = tags
        if not self.audio:
            raise Exception("write_gain called without previous read_gain")
        if isinstance(self.audio, mutagen.id3.ID3FileType):
            self.write_gain_id3()
        if isinstance(self.audio, mutagen.oggopus.OggOpus):
            self.write_gain_ogg_opus()
        if isinstance(self.audio, mutagen.mp4.MP4):
            self.write_gain_mp4()
        self.write_gain_generic()

class GainScanner:
    i_re = re.compile(r"^\s+I:\s+(-?\d+\.\d+) LUFS$", re.M)
    peak_re = re.compile(r"^\s+Peak:\s+(-?\d+\.\d+) dBFS$", re.M)

    @asyncio.coroutine
    def ffmpeg_parse_ebur128(self, *ff_opts):
        ff_args = ['ffmpeg', '-nostats', '-nostdin', '-hide_banner',
                '-loglevel', 'info'] + list(ff_opts) + ['-f', 'null', '-']
        ffmpeg = yield from asyncio.create_subprocess_exec(*ff_args,
                stdin=subprocess.DEVNULL, stdout=subprocess.DEVNULL,
                stderr=subprocess.PIPE)
        (_, stderr_data) = yield from ffmpeg.communicate()
        stderr_str = stderr_data.decode()

        result = GainInfo()
        m = self.i_re.search(stderr_str)
        if m:
            result.loudness = float(m.group(1))
        m = self.peak_re.search(stderr_str)
        if m:
            result.peak = float(m.group(1))

        return result

    @asyncio.coroutine
    def scan_track(self, filename):
        result = yield from self.ffmpeg_parse_ebur128('-i', filename,
                '-filter_complex', 'ebur128=framelog=verbose:peak=true')
        return result

    @asyncio.coroutine
    def scan_album(self, filenames):
        if len(filenames) == 0:
            raise ValueError("filenames is empty")
        ff_args = []
        for filename in filenames:
            ff_args += ['-i', filename]
        ff_args += ['-filter_complex',
                'concat=n={}:v=0:a=1,ebur128=framelog=verbose'.format(len(filenames))]
        result = yield from self.ffmpeg_parse_ebur128(*ff_args)
        return GainInfo(album_loudness=result.loudness, album_peak=result.peak)

class Track:
    def __init__(self, filename, job_sem):
        self.filename = filename
        self.job_sem = job_sem
        self.tagger = Tagger(filename)
        self.gain = GainInfo()

    @asyncio.coroutine
    def read_tags(self):
        with (yield from self.job_sem):
            loop = asyncio.get_event_loop()
            self.gain = yield from loop.run_in_executor(None,
                    self.tagger.read_gain)

        need_scan = False
        if self.gain.loudness is None or self.gain.peak is None:
            need_scan = True

        return need_scan

    @asyncio.coroutine
    def scan_gain(self):
        with (yield from self.job_sem):
            gain_scanner = GainScanner()
            self.gain = yield from gain_scanner.scan_track(self.filename)

    @asyncio.coroutine
    def write_tags(self):
        with (yield from self.job_sem):
            loop = asyncio.get_event_loop()
            yield from loop.run_in_executor(None,
                    self.tagger.write_gain, self.gain)

    @asyncio.coroutine
    def scan(self, force=False):
        need_scan = yield from self.read_tags()

        if force:
            need_scan = True

        if not need_scan:
            print()
            print(self.filename)
            print(self.gain)
            print('Track does not need rescanning.')
            return

        yield from self.scan_gain()

        print()
        print(self.filename)
        print(self.gain)

class AlbumTrack(Track):
    def __init__(self, filename, job_sem, exclude):
        super().__init__(filename, job_sem)
        self.exclude = exclude

class Album:
    def __init__(self, album_param, job_sem):
        self.job_sem = job_sem

        self.gain = GainInfo()
        self.tracks = []
        for filename in album_param['track']:
            self.tracks.append(AlbumTrack(filename, job_sem, exclude=False))
        for filename in album_param['exclude']:
            self.tracks.append(AlbumTrack(filename, job_sem, exclude=True))

    @asyncio.coroutine
    def read_tags(self):
        track_tasks = [track.read_tags() for track in self.tracks]
        track_need_scans = yield from asyncio.gather(*track_tasks)

        need_scan = False
        for track, track_need_scan in zip(self.tracks, track_need_scans):
            if track_need_scan:
                need_scan = True
            if self.gain.album_loudness is None:
                self.gain.album_loudness = track.gain.album_loudness
            if self.gain.album_loudness != track.gain.album_loudness:
                need_scan = True
            if self.gain.album_peak is None:
                self.gain.album_peak = track.gain.album_peak
            if self.gain.album_peak != track.gain.album_peak:
                need_scan = True
        if self.gain.album_loudness is None or self.gain.album_peak is None:
            need_scan = True

        return need_scan

    @asyncio.coroutine
    def scan_album_gain(self):
        included = [t.filename for t in self.tracks if not t.exclude]
        with (yield from self.job_sem):
            gain_scanner = GainScanner()
            self.gain = yield from gain_scanner.scan_album(included)

    @asyncio.coroutine
    def scan_gain(self):
        track_tasks = [track.scan_gain() for track in self.tracks]

        yield from asyncio.gather(self.scan_album_gain(), *track_tasks)

        self.gain.album_peak = max([t.gain.peak for t in self.tracks])
        for track in self.tracks:
            track.gain.album_loudness = self.gain.album_loudness
            track.gain.album_peak = self.gain.album_peak

        return

    @asyncio.coroutine
    def write_tags(self):
        track_tasks = [track.write_tags() for track in self.tracks]
        yield from asyncio.gather(*track_tasks)

    @asyncio.coroutine
    def scan(self, force=False):
        need_scan = yield from self.read_tags()

        if force:
            need_scan = True

        if not need_scan:
            print()
            for track in self.tracks:
                print(track.filename)
                print(track.gain)
            print('Album does not need rescanning')
            return

        yield from self.scan_gain()

        yield from self.write_tags()

        print()
        for track in self.tracks:
            print(track.filename)
            print(track.gain)

loop = asyncio.get_event_loop()

job_sem = asyncio.BoundedSemaphore(args.jobs)

tasks = []
tracks = [Track(track, job_sem) for track in args.track]
tasks += [track.scan(force=args.force) for track in tracks]
albums = [Album(album, job_sem) for album in args.album]
tasks += [album.scan(force=args.force) for album in albums]

future = asyncio.async(asyncio.gather(*tasks))

loop.run_until_complete(future)

future.result()

loop.close()
