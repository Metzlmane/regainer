#!/usr/bin/env python3

# regainer - advanced ReplayGain tagging
# Copyright â’¸ 2015 Calvin Walton <calvin.walton@kepstin.ca>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, contact the Free Software Foundation
# for a copy, or see http://www.gnu.org/licenses/old-licenses/gpl-2.0.html

import subprocess
import argparse
import asyncio
import multiprocessing
import re
from collections import deque
import mutagen
from math import log10
from enum import Enum
import sys

class AlbumAction(argparse.Action):
    def __init__(self, option_strings, dest, **kwargs):
        super(AlbumAction, self).__init__(option_strings, dest, **kwargs)
    def __call__(self, parser, namespace, values, option_string=None):
        if namespace.album is None:
            namespace.album = deque()
        if option_string == '-a' or option_string == '--album':
            namespace.album.append({'track': deque(values), 'exclude': deque()})
        if option_string == '-e' or option_string == '--exclude':
            if len(namespace.album) == 0:
                if namespace.exclude is None:
                    namespace.exclude = values
                else:
                    namespace.exclude.extend(values)
            else:
                namespace.album[-1]['exclude'].extend(values)

class TrackAction(argparse.Action):
    def __init__(self, option_strings, dest, **kwargs):
        super(TrackAction, self).__init__(option_strings, dest, **kwargs)
    def __call__(self, parser, namespace, values, option_string=None):
        if namespace.track is None:
            namespace.track = deque(values)
        else:
            namespace.track.extend(values)

parser = argparse.ArgumentParser(
        description='''
        Add ReplayGain tags to files using the EBU R128 algorithm.
        ''',
        epilog='''
        If neither --track or --album are specified, the mode used depends on
        the number of files given as arguments. If a single file is given, it
        will be processed in track mode. If multiple files are given, they
        will be processed in album mode as a single album.
        ''')
parser.add_argument('-n', '--dry-run', default=False, action='store_true',
        help='''
        Only calculate and display the ReplayGain values; do not actually
        save the tags in the audio files.
        ''')
parser.add_argument('-f', '--force', default=False, action='store_true',
        help='''
        Recalculate the ReplayGain values even if valid tags are already
        present in the files.
        ''')
parser.add_argument('-j', '--jobs', type=int,
        default=multiprocessing.cpu_count(),
        help='''
        The number of operations to run in parallel. The default is
        auto-detected, currently %(default)s.
        ''')
parser.add_argument('-t', '--track', nargs='+', default=deque(),
        metavar='FILE', action=TrackAction,
        help='''
        Treat the following audio files as individual tracks.
        ''')
parser.add_argument('-a', '--album', nargs='+', default=deque(),
        metavar='FILE', action=AlbumAction,
        help='''
        Treat the following audio files as part of the same album.
        Each time the --album option is specified, it starts a new album.
        ''')
parser.add_argument('-e', '--exclude', nargs='+', default=deque(),
        metavar='FILE', action=AlbumAction,
        help='''
        Tag the following files as part of the current album, but do not
        use their audio when calculating the value for the album ReplayGain
        tag.
        ''')
parser.add_argument('FILE', nargs='*', default=[], help=argparse.SUPPRESS)
args = parser.parse_args()

print(args)

# Handle the "loose" arguments, by turning them into tracks or albums
if len(args.FILE) + len(args.exclude) > 1 or len(args.exclude) > 0:
    # Treat the initial arguments as an album
    args.album.appendleft(
            {'track': deque(args.FILE), 'exclude': deque(args.exclude)})
    args.FILE = None
    args.exclude = None
elif len(args.FILE) > 0:
    args.track.extend(args.FILE)
    args.FILE = None

if len(args.track) == 0 and len(args.album) == 0:
    parser.print_usage()
    sys.exit(2)

class GainInfo:
    def __init__(self, loudness=None, album_loudness=None,
            peak=None, album_peak=None):
        self.loudness = loudness
        self.album_loudness = album_loudness
        self.peak = peak
        self.album_peak = album_peak

    def __str__(self):
        str = ''
        str += 'Track: '
        if self.loudness is None:
            str += 'I: None'
        else:
            str += 'I: {:.2f} LUFS'.format(self.loudness)
        str += ', '
        if self.peak is None:
            str += 'Peak: None'
        else:
            str += 'Peak: {:.2f} dBFS'.format(self.peak)
        str += '; Album: '
        if self.album_loudness is None:
            str += 'I: None'
        else:
            str += 'I: {:.2f} LUFS'.format(self.album_loudness)
        str += ', '
        if self.album_peak is None:
            str += 'Peak: None'
        else:
            str += 'Peak: {:.2f} dBFS'.format(self.album_peak)
        return str

class OggOpusMode(Enum):
    R128 = 1
    """
    Write R128 gain tags as specified in the Ogg Opus encapsulation doc.

    This writes the tags R128_TRACK_GAIN and R128_ALBUM_GAIN to the file,
    and removes any REPLAYGAIN tags that may be present. The R128 gain tags
    use the EBU R128 -23 LUFS reference level.

    This method is the most standards compliant, but has limited application
    compatibility.
    """

    REPLAYGAIN = 2
    """
    Write REPLAYGAIN tags compatible with FLAC, Vorbis, etc.

    This writes the tags REPLAYGAIN_{TRACK,ALBUM}_{GAIN,PEAK} to the file,
    and removes any R128 gain tags that may be present. The REPLAYGAIN tags
    use the -18 LUFS reference level from ReplayGain 2.0.

    This method is against the spirit of the specifications, but has good
    application compatibility (most applications share parsing code between
    Opus tags and other formats).
    """

    COMPATIBLE = 3
    """
    Write both R128 gain and REPLAYGAIN tags.

    This writes the tags from both the "standard" and "replaygain" modes at
    the same time.

    This method is against the spirit of the specifications, but ensures
    maximum application compatibility. Since the same computed gain value
    is used to generate both sets of tags (adjusted the the appropriate
    different reference levels), it doesn't matter which one the application
    uses - the result will be the same.

    This is the default tagging method.
    """
class ID3Mode(Enum):
    REPLAYGAIN = 1
    """Write REPLAYGAIN tags according to the ReplayGain 2.0 spec."""

    RVA2 = 2
    """Use the ID3v2 RVA2 frames to store ReplayGain information."""

    COMPATIBLE = 3
    """
    Write both REPLAYGAIN tags and RVA2 frames.

    This is the default tagging method.
    """

class Tagger:
    REPLAYGAIN_REF = -18.0 # LUFS
    R128_REF = -23.0 # LUFS

    ogg_opus_mode = OggOpusMode.COMPATIBLE
    id3_mode = ID3Mode.COMPATIBLE

    def __init__(self, filename):
        self.filename = filename
        self.tags = GainInfo()

    rg_gain_re = re.compile(r"^\s*([+-]?\d+(?:\.\d+)?)")
    def parse_rg_gain(self, value):
        m = self.rg_gain_re.match(value)
        if m:
            return self.REPLAYGAIN_REF - float(m.group(1))
        return None

    def format_rg_gain(self, loudness):
        return "{:.2f} dB".format(self.REPLAYGAIN_REF - loudness)


    rg_peak_re = re.compile(r"^\s*([+-]?\d+(?:\.\d+)?)")
    def parse_rg_peak(self, value):
        m = self.rg_peak_re.match(value)
        if m:
            return 20.0 * log10(float(m.group(1)))
        return None

    def format_rg_peak(self, peak):
        return "{:.6f}".format(10.0 ** (peak / 20.0))

    opus_gain_re = re.compile(r"^\s*([+-]?\d{1,5})")
    def parse_opus_gain(self, value):
        m = self.opus_gain_re.match(value)
        if m:
            return self.R128_REF - float(m.group(1)) / 256.0

    def format_opus_gain(self, value):
        value = int(value * 256.0)
        if value < -32768 or value > 32767:
            raise ValueError('Opus gain value out of range')
        return "{:d}".format(value)
        

    def read_gain_id3(self):
        for tag in self.audio.tags.getall('TXXX'):
            if tag.desc.lower() == 'replaygain_track_gain':
                if self.tags.loudness is None:
                    self.tags.loudness = self.parse_rg_gain(tag.text[0])
                continue
            if tag.desc.lower() == 'replaygain_track_peak':
                if self.tags.peak is None:
                    self.tags.peak = self.parse_rg_peak(tag.text[0])
                continue
            if tag.desc.lower() == 'replaygain_album_gain':
                if self.tags.album_loudness is None:
                    self.tags.album_loudness = self.parse_rg_gain(tag.text[0])
                continue
            if tag.desc.lower() == 'replaygain_album_peak':
                if self.tags.album_peak is None:
                    self.tags.album_peak = self.parse_rg_peak(tag.text[0])
                continue

        # Try loading the legacy RVA2 tags if information is missing
        if self.tags.loudness is None or self.tags.peak is None:
            rva2_t = self.audio.tags.get('RVA2:track')
            if rva2_t and rva2_t.channel == 1:
                self.tags.loudness = self.REPLAYGAIN_REF - rva2_t.gain
                self.tags.peak = 20.0 * log10(rva2_t.peak)
        if self.tags.album_loudness is None or self.tags.album_peak is None:
            rva2_a = self.audio.tags.get('RVA2:album')
            if rva2_a and rva2_a.channel == 1:
                self.tags.album_loudness = self.REPLAYGAIN_REF - rva2_a.gain
                self.tags.album_peak = 20.0 * log10(rva2_a.peak)

        return self.tags

    def read_gain_ogg_opus(self):
        if self.tags.loudness is None:
            r128_tg = self.audio.get('R128_TRACK_GAIN')
            if r128_tg:
                self.tags.loudness = self.parse_opus_gain(r128_tg[0])
                # This is a hack, R128 gain tags don't store peak, but
                # we want to mark it as valid tag even without the peak
                if 'REPLAYGAIN_TRACK_PEAK' not in self.audio:
                    self.tags.peak = float('nan')
        if self.tags.album_loudness is None:
            r128_ag = self.audio.get('R128_ALBUM_GAIN')
            if r128_ag:
                self.tags.album_loudness = self.parse_opus_gain(r128_ag[0])
                if 'REPLAYGAIN_ALBUM_PEAK' not in self.audio:
                    self.tags.album_peak = float('nan')

        # For compatibility, also read the generic tags
        return self.read_gain_generic()

    def read_gain_mp4(self):
        # These are the tags used by foobar2000, and are compatible with
        # rockbox.
        for key, value in self.audio.tags.items():
            atom_name = key[:4]
            if atom_name != '----':
                continue

            _, mean, name = key.split(':', 2)

            if not (mean == 'com.apple.iTunes' or \
                    mean == 'org.hydrogenaudio.replaygain'):
                continue

            if value[0].dataformat == mutagen.mp4.AtomDataType.UTF8:
                value = value[0].decode(encoding='UTF-8')
            else:
                continue

            name = name.lower()
            if name == 'replaygain_track_gain':
                if self.tags.loudness is None:
                    self.tags.loudness = self.parse_rg_gain(value)
                continue
            if name == 'replaygain_track_peak':
                if self.tags.peak is None:
                    self.tags.peak = self.parse_rg_peak(value)
                continue
            if name == 'replaygain_album_gain':
                if self.tags.album_loudness is None:
                    self.tags.album_loudness = self.parse_rg_gain(value)
                continue
            if name == 'replaygain_album_peak':
                if self.tags.album_peak is None:
                    self.tags.album_peak = self.parse_rg_peak(value)
                continue

        return self.tags

    def read_gain_generic(self):
        if self.tags.loudness is None:
            rg_tg = self.audio.get('REPLAYGAIN_TRACK_GAIN')
            if rg_tg:
                self.tags.loudness = self.parse_rg_gain(rg_tg[0])
        if self.tags.peak is None:
            rg_tp = self.audio.get('REPLAYGAIN_TRACK_PEAK')
            if rg_tp:
                self.tags.peak = self.parse_rg_peak(rg_tp[0])
        if self.tags.album_loudness is None:
            rg_ag = self.audio.get('REPLAYGAIN_ALBUM_GAIN')
            if rg_ag:
                self.tags.album_loudness = self.parse_rg_gain(rg_ag[0])
        if self.tags.album_peak is None:
            rg_ap = self.audio.get('REPLAYGAIN_ALBUM_PEAK')
            if rg_ap:
                self.tags.album_peak = self.parse_rg_peak(rg_ap[0])

        return self.tags

    def read_gain(self):
        self.audio = mutagen.File(self.filename)
        if isinstance(self.audio.tags, mutagen.id3.ID3):
            return self.read_gain_id3()
        if isinstance(self.audio, mutagen.oggopus.OggOpus):
            return self.read_gain_ogg_opus()
        if isinstance(self.audio, mutagen.mp4.MP4):
            return self.read_gain_mp4()
        return self.read_gain_generic()

    def write_gain_id3(self):
        # Delete standard ReplayGain tags
        to_delete = []
        for tag in self.audio.tags.getall('TXXX'):
            name = tag.desc.lower()
            if name == 'replaygain_track_gain' or \
                    name == 'replaygain_track_peak' or \
                    name == 'replaygain_album_gain' or \
                    name == 'replaygain_album_peak' or \
                    name == 'replaygain_reference_loudness':
                to_delete.append(tag.HashKey)
        for key in to_delete:
            del self.audio.tags[key]
        # Delete RVA2 frames
        if 'RVA2:track' in self.audio:
            del self.audio['RVA2:track']
        if 'RVA2:album' in self.audio:
            del self.audio['RVA2:album']

        if self.id3_mode is ID3Mode.REPLAYGAIN or \
                self.id3_mode is ID3Mode.COMPATIBLE:
            if self.tags.loudness is not None:
                self.audio.tags.add(mutagen.id3.TXXX(
                    encoding=0,
                    desc='REPLAYGAIN_TRACK_GAIN',
                    text=[self.format_rg_gain(self.tags.loudness)]))
            if self.tags.peak is not None:
                self.audio.tags.add(mutagen.id3.TXXX(
                    encoding=0,
                    desc='REPLAYGAIN_TRACK_PEAK',
                    text=[self.format_rg_peak(self.tags.peak)]))
            if self.tags.album_loudness is not None:
                self.audio.tags.add(mutagen.id3.TXXX(
                    encoding=0,
                    desc='REPLAYGAIN_ALBUM_GAIN',
                    text=[self.format_rg_gain(self.tags.album_loudness)]))
            if self.tags.album_peak is not None:
                self.audio.tags.add(mutagen.id3.TXXX(
                    encoding=0,
                    desc='REPLAYGAIN_ALBUM_PEAK',
                    text=[self.format_rg_peak(self.tags.album_peak)]))

        if self.id3_mode is ID3Mode.RVA2 or \
                self.id3_mode is ID3Mode.COMPATIBLE:
            if self.tags.loudness is not None and \
                    self.tags.peak is not None:
                self.audio.tags.add(mutagen.id3.RVA2(
                    desc='track',
                    channel=1,
                    gain=self.REPLAYGAIN_REF - self.tags.loudness,
                    peak=10.0 ** (self.tags.peak / 20.0)))
            if self.tags.album_loudness is not None and \
                    self.tags.album_peak is not None:
                self.audio.tags.add(mutagen.id3.RVA2(
                    desc='track',
                    channel=1,
                    gain=self.REPLAYGAIN_REF - self.tags.album_loudness,
                    peak=10.00 ** (self.tags.album_peak / 20.0)))

        self.audio.tags.update_to_v24()
        self.audio.save()

    def write_gain_ogg_opus(self):
        # Delete all tags, particularly needed if switching modes
        self.write_gain_generic_cleanup()

        if self.ogg_opus_mode is OggOpusMode.R128 or \
                self.ogg_opus_mode is OggOpusMode.COMPATIBLE:
            if self.tags.loudness is not None:
                self.audio['R128_TRACK_GAIN'] = \
                        [self.format_opus_gain(self.tags.loudness)]
            if self.tags.album_loudness is not None:
                self.audio['R128_ALBUM_GAIN'] = \
                        [self.format_opus_gain(self.tags.album_loudness)]

        if self.ogg_opus_mode is OggOpusMode.REPLAYGAIN or \
                self.ogg_opus_mode is OggOpusMode.COMPATIBLE:
            if self.tags.loudness is not None:
                self.audio['REPLAYGAIN_TRACK_GAIN'] = \
                        [self.format_rg_gain(self.tags.loudness)]
            if self.tags.peak is not None:
                self.audio['REPLAYGAIN_TRACK_PEAK'] = \
                        [self.format_rg_peak(self.tags.peak)]
            if self.tags.album_loudness is not None:
                self.audio['REPLAYGAIN_ALBUM_GAIN'] = \
                        [self.format_rg_gain(self.tags.album_loudness)]
            if self.tags.album_peak is not None:
                self.audio['REPLAYGAIN_ALBUM_PEAK'] = \
                        [self.format_rg_peak(self.tags.album_peak)]

        self.audio.save()

    def write_gain_mp4(self):
        to_delete = []
        for key, value in self.audio.tags.items():
            atom_name = key[:4]
            if atom_name != '----':
                continue

            _, mean, name = key.split(':', 2)

            if not (mean == 'com.apple.iTunes' or \
                    mean == 'org.hydrogenaudio.replaygain'):
                continue

            if value[0].dataformat == mutagen.mp4.AtomDataType.UTF8:
                value = value[0].decode(encoding='UTF-8')
            else:
                continue

            name = name.lower()
            if name == 'replaygain_track_gain' or \
                    name == 'replaygain_track_peak' or \
                    name == 'replaygain_album_gain' or \
                    name == 'replaygain_album_peak':
                to_delete.append(key)
        for key in to_delete:
            del self.audio.tags[key]

        # These are the tags used by foobar2000, and are compatible with
        # rockbox.
        if self.tags.loudness is not None:
            self.audio.tags['----:com.apple.iTunes:REPLAYGAIN_TRACK_GAIN'] = \
                    [mutagen.mp4.MP4FreeForm(
                        self.format_rg_gain(self.tags.loudness).encode(
                            encoding='UTF-8'))]
        if self.tags.peak is not None:
            self.audio.tags['----:com.apple.iTunes:REPLAYGAIN_TRACK_PEAK'] = \
                    [mutagen.mp4.MP4FreeForm(
                        self.format_rg_peak(self.tags.peak).encode(
                            encoding='UTF-8'))]
        if self.tags.album_loudness is not None:
            self.audio.tags['----:com.apple.iTunes:REPLAYGAIN_ALBUM_GAIN'] = \
                    [mutagen.mp4.MP4FreeForm(
                        self.format_rg_gain(self.tags.album_loudness).encode(
                            encoding='UTF-8'))]
        if self.tags.album_peak is not None:
            self.audio.tags['----:com.apple.iTunes:REPLAYGAIN_ALBUM_PEAK'] = \
                    [mutagen.mp4.MP4FreeForm(
                        self.format_rg_peak(self.tags.album_peak).encode(
                            encoding='UTF-8'))]

        self.audio.save()


    def write_gain_generic_cleanup(self):
        # Delete the standard tags
        if 'REPLAYGAIN_TRACK_GAIN' in self.audio:
            del self.audio['REPLAYGAIN_TRACK_GAIN']
        if 'REPLAYGAIN_TRACK_PEAK' in self.audio:
            del self.audio['REPLAYGAIN_TRACK_PEAK']
        if 'REPLAYGAIN_ALBUM_GAIN' in self.audio:
            del self.audio['REPLAYGAIN_ALBUM_GAIN']
        if 'REPLAYGAIN_ALBUM_PEAK' in self.audio:
            del self.audio['REPLAYGAIN_ALBUM_PEAK']
        # Delete unusual/old tags
        if 'REPLAYGAIN_REFERENCE_LOUDNESS' in self.audio:
            del self.audio['REPLAYGAIN_REFERENCE_LOUDNESS']
        # Ogg Opus R128 gain tags (shouldn't ever be in other formats...)
        if 'R128_TRACK_GAIN' in self.audio:
            del self.audio['R128_TRACK_GAIN']
        if 'R128_ALBUM_GAIN' in self.audio:
            del self.audio['R128_ALBUM_GAIN']

    def write_gain_generic(self):
        self.write_gain_generic_cleanup()

        if self.tags.loudness is not None:
            self.audio['REPLAYGAIN_TRACK_GAIN'] = \
                    [self.format_rg_gain(self.tags.loudness)]
        if self.tags.peak is not None:
            self.audio['REPLAYGAIN_TRACK_PEAK'] = \
                    [self.format_rg_peak(self.tags.peak)]
        if self.tags.album_loudness is not None:
            self.audio['REPLAYGAIN_ALBUM_GAIN'] = \
                    [self.format_rg_gain(self.tags.album_loudness)]
        if self.tags.album_peak is not None:
            self.audio['REPLAYGAIN_ALBUM_PEAK'] = \
                    [self.format_rg_peak(self.tags.album_peak)]

        self.audio.save()

    def write_gain(self, tags):
        self.tags = tags
        if not self.audio:
            raise Exception("write_gain called without previous read_gain")
        if isinstance(self.audio.tags, mutagen.id3.ID3):
            return self.write_gain_id3()
        if isinstance(self.audio, mutagen.oggopus.OggOpus):
            return self.write_gain_ogg_opus()
        if isinstance(self.audio, mutagen.mp4.MP4):
            return self.write_gain_mp4()
        return self.write_gain_generic()

class GainScanner:
    i_re = re.compile(r"^\s+I:\s+(-?\d+\.\d+) LUFS$", re.M)
    peak_re = re.compile(r"^\s+Peak:\s+(-?\d+\.\d+) dBFS$", re.M)

    @asyncio.coroutine
    def ffmpeg_parse_ebur128(self, *ff_opts):
        ff_args = ['ffmpeg', '-nostats', '-nostdin', '-hide_banner',
                '-loglevel', 'info'] + list(ff_opts) + ['-f', 'null', '-']
        ffmpeg = yield from asyncio.create_subprocess_exec(*ff_args,
                stdin=subprocess.DEVNULL, stdout=subprocess.DEVNULL,
                stderr=subprocess.PIPE)
        (_, stderr_data) = yield from ffmpeg.communicate()
        stderr_str = stderr_data.decode()

        result = GainInfo()
        m = self.i_re.search(stderr_str)
        if m:
            result.loudness = float(m.group(1))
        m = self.peak_re.search(stderr_str)
        if m:
            result.peak = float(m.group(1))

        return result

    @asyncio.coroutine
    def scan_track(self, filename):
        result = yield from self.ffmpeg_parse_ebur128('-i', filename,
                '-filter_complex', 'ebur128=framelog=verbose:peak=true')
        return result

    @asyncio.coroutine
    def scan_album(self, filenames):
        if len(filenames) == 0:
            raise ValueError("filenames is empty")
        ff_args = []
        for filename in filenames:
            ff_args += ['-i', filename]
        ff_args += ['-filter_complex',
                'concat=n={}:v=0:a=1,ebur128=framelog=verbose'.format(len(filenames))]
        result = yield from self.ffmpeg_parse_ebur128(*ff_args)
        return GainInfo(album_loudness=result.loudness, album_peak=result.peak)

class Track:
    def __init__(self, filename, job_sem):
        self.filename = filename
        self.job_sem = job_sem
        self.tagger = Tagger(filename)
        self.gain = GainInfo()

    @asyncio.coroutine
    def read_tags(self):
        with (yield from self.job_sem):
            loop = asyncio.get_event_loop()
            self.gain = yield from loop.run_in_executor(None,
                    self.tagger.read_gain)

        need_scan = False
        if self.gain.loudness is None or self.gain.peak is None:
            need_scan = True

        return need_scan

    @asyncio.coroutine
    def scan_gain(self):
        with (yield from self.job_sem):
            gain_scanner = GainScanner()
            self.gain = yield from gain_scanner.scan_track(self.filename)

    @asyncio.coroutine
    def write_tags(self):
        with (yield from self.job_sem):
            loop = asyncio.get_event_loop()
            yield from loop.run_in_executor(None,
                    self.tagger.write_gain, self.gain)

    @asyncio.coroutine
    def scan(self, force=False, skip_save=False):
        need_scan = yield from self.read_tags()

        if force:
            need_scan = True

        if not need_scan:
            print()
            print(self.filename)
            print(self.gain)
            print('Track does not need rescanning.')
            return

        yield from self.scan_gain()

        if not skip_save:
            yield from self.write_tags()

        print()
        print(self.filename)
        print(self.gain)

class AlbumTrack(Track):
    def __init__(self, filename, job_sem, exclude):
        super().__init__(filename, job_sem)
        self.exclude = exclude

class Album:
    def __init__(self, album_param, job_sem):
        self.job_sem = job_sem

        self.gain = GainInfo()
        self.tracks = []
        for filename in album_param['track']:
            self.tracks.append(AlbumTrack(filename, job_sem, exclude=False))
        for filename in album_param['exclude']:
            self.tracks.append(AlbumTrack(filename, job_sem, exclude=True))

    @asyncio.coroutine
    def read_tags(self):
        track_tasks = [track.read_tags() for track in self.tracks]
        track_need_scans = yield from asyncio.gather(*track_tasks)

        need_scan = False
        for track, track_need_scan in zip(self.tracks, track_need_scans):
            if track_need_scan:
                need_scan = True
            if self.gain.album_loudness is None:
                self.gain.album_loudness = track.gain.album_loudness
            if self.gain.album_loudness != track.gain.album_loudness:
                need_scan = True
            if self.gain.album_peak is None:
                self.gain.album_peak = track.gain.album_peak
            if self.gain.album_peak != track.gain.album_peak:
                need_scan = True
        if self.gain.album_loudness is None or self.gain.album_peak is None:
            need_scan = True

        return need_scan

    @asyncio.coroutine
    def scan_album_gain(self):
        included = [t.filename for t in self.tracks if not t.exclude]
        with (yield from self.job_sem):
            gain_scanner = GainScanner()
            self.gain = yield from gain_scanner.scan_album(included)

    @asyncio.coroutine
    def scan_gain(self):
        track_tasks = [track.scan_gain() for track in self.tracks]

        yield from asyncio.gather(self.scan_album_gain(), *track_tasks)

        self.gain.album_peak = max([t.gain.peak for t in self.tracks])
        for track in self.tracks:
            track.gain.album_loudness = self.gain.album_loudness
            track.gain.album_peak = self.gain.album_peak

        return

    @asyncio.coroutine
    def write_tags(self):
        track_tasks = [track.write_tags() for track in self.tracks]
        yield from asyncio.gather(*track_tasks)

    @asyncio.coroutine
    def scan(self, force=False, skip_save=False):
        need_scan = yield from self.read_tags()

        if force:
            need_scan = True

        if not need_scan:
            print()
            for track in self.tracks:
                print(track.filename)
                print(track.gain)
            print('Album does not need rescanning')
            return

        yield from self.scan_gain()

        if not skip_save:
            yield from self.write_tags()

        print()
        for track in self.tracks:
            print(track.filename)
            print(track.gain)

loop = asyncio.get_event_loop()

job_sem = asyncio.BoundedSemaphore(args.jobs)

tasks = []
tracks = [Track(track, job_sem) for track in args.track]
tasks += [track.scan(force=args.force, skip_save=args.dry_run)
                for track in tracks]
albums = [Album(album, job_sem) for album in args.album]
tasks += [album.scan(force=args.force, skip_save=args.dry_run)
                for album in albums]

future = asyncio.async(asyncio.gather(*tasks))

loop.run_until_complete(future)

future.result()

loop.close()
